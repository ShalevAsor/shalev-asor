---
title: "E-Commerce Store Template"
slug: "ecommerce"
description: "Production-ready e-commerce template with advanced checkout, payment recovery, and multi-provider support"
date: "2025-09-10"
published: true
featured: false
tags:
  [
    "nextjs",
    "typescript",
    "prisma",
    "postgresql",
    "paypal",
    "aws-s3",
    "ecommerce",
  ]
github: "https://github.com/ShalevAsor/store-template"
demo: "https://store-template-zeta.vercel.app"
image: ../../../public/images/projects/store-template/main.png
---

## Overview

I got tired of rebuilding the same e-commerce stuff every time someone needed a store. Payments, webhooks, stock management - it's always the same problems. So I built this template to save myself (and anyone else) weeks of work.

<Callout type="success" title="Template Philosophy">
  - **Clone, don't build** → Fork the repo, customize branding, deploy -
  **Production-ready** → All the edge cases handled (webhook race conditions,
  stock validation, payment recovery) - **Provider-agnostic** → Payment system
  supports multiple providers (PayPal, Stripe, etc.) - **Admin included** → Full
  admin dashboard for managing products and orders
</Callout>

**What makes this special:** Most templates ignore the annoying edge cases. What happens when PayPal's webhook arrives before your capture request? What if two people checkout the last item at the same time? What about those orphaned S3 images that cost you money? I spent way too much time on these problems, so you don't have to.

<Stats>
  <StatCard value="Provider-Agnostic" label="Payment System" trend="up" />
  <StatCard
    value="40 Seconds"
    label="Payment Recovery Window"
    trend="neutral"
  />
  <StatCard value="Atomic" label="Checkout Transactions" trend="up" />
  <StatCard value="Direct S3" label="Image Uploads" trend="up" />
</Stats>

## Tech Stack

<Tabs defaultTab={0}>
  <TabItem label="Frontend">
    <TechStack
      title="Core Framework"
      items={[
        "Next.js with App Router for server and client components",
        "React with full Server Components support",
        "TypeScript for complete type safety",
        "Tailwind CSS 4 for styling with dark mode",
      ]}
    />
    <TechStack
      title="State Management"
      items={[
        "Zustand for cart state with localStorage persistence",
        "React Query for server state caching and refetching",
        "React Hook Form for performant form handling",
        "Zod for runtime schema validation",
      ]}
    />
    <TechStack
      title="UI Components"
      items={[
        "shadcn/ui component library for consistent design",
        "Lucide React for icon system",
        "Embla Carousel for product image galleries",
        "Sonner for toast notifications",
      ]}
    />
  </TabItem>
  <TabItem label="Backend & Database">
    <TechStack
      title="Database"
      items={[
        "PostgreSQL for primary data storage",
        "Prisma as type-safe ORM",
        "Database models: Products, ProductImages, Orders, OrderItems, StoreSettings",
        "Migrations for schema versioning",
        "Transactions for atomic checkout operations",
      ]}
    />
    <TechStack
      title="Server Actions & API"
      items={[
        "Next.js Server Actions for type-safe mutations",
        "API Routes for webhooks and external integrations",
        "Cache revalidation with tags",
        "unstable_cache for settings with 1-hour TTL",
      ]}
    />
    <TechStack
      title="Authentication"
      items={[
        "Simple password-based admin auth (environment variable)",
        "HTTP-only cookie sessions",
        "Middleware for route protection",
        "Future-ready for NextAuth/Clerk integration",
      ]}
    />
  </TabItem>
  <TabItem label="Payments & Storage">
    <TechStack
      title="Payment System"
      items={[
        "PayPal SDK for PayPal integration",
        "Provider-agnostic architecture (supports multiple payment gateways)",
        "Factory pattern for dynamic provider instantiation",
        "Webhook handling with signature verification",
        "Payment recovery system with polling",
        "Refund support (full and partial)",
      ]}
    />
    <TechStack
      title="File Storage"
      items={[
        "AWS S3 for image storage",
        "Presigned URLs for direct client-to-S3 uploads",
        "Automatic cleanup on product deletion or update",
        "CDN delivery for fast image loading",
        "Secure filename generation",
      ]}
    />
  </TabItem>
</Tabs>

## Project Architecture

<FileTree>
  {`ecommerce-store/
├── src/
│   ├── app/
│   │   ├── (main)/                  # Customer-facing routes
│   │   │   ├── page.tsx             # Homepage
│   │   │   ├── products/            # Product listing & details
│   │   │   ├── cart/                # Shopping cart
│   │   │   ├── checkout/            # Multi-step checkout
│   │   │   │   ├── page.tsx         # Checkout form & payment
│   │   │   │   └── success/[orderId]/ # Order confirmation
│   │   │   └── layout.tsx
│   │   ├── admin/                   # Admin dashboard
│   │   │   ├── login/               # Admin login
│   │   │   ├── products/            # Product management
│   │   │   ├── orders/              # Order management
│   │   │   ├── settings/            # Store settings
│   │   │   └── layout.tsx
│   │   └── api/
│   │       ├── upload-url/          # S3 presigned URL generation
│   │       ├── webhooks/payment/    # Payment webhooks
│   │       └── admin/login/         # Admin auth
│   ├── components/
│   │   ├── admin/
│   │   │   ├── products/
│   │   │   │   ├── ProductForm.tsx  # Product CRUD form
│   │   │   │   └── ProductTable.tsx
│   │   │   ├── orders/
│   │   │   │   ├── OrderTable.tsx
│   │   │   │   └── OrderActionsDropdown.tsx
│   │   │   └── settings/
│   │   ├── cart/
│   │   │   ├── AddToCartButton.tsx  # Stock validation
│   │   │   ├── CartItem.tsx
│   │   │   └── CartSummary.tsx
│   │   ├── checkout/
│   │   │   ├── CheckoutClient.tsx   # Main orchestrator
│   │   │   ├── CheckoutForm.tsx
│   │   │   └── PaymentSection.tsx
│   │   ├── modals/
│   │   │   ├── StockConfirmationModal.tsx
│   │   │   └── OrderStatusModal.tsx
│   │   └── products/
│   │       ├── ProductCard.tsx
│   │       └── ProductImageGallery.tsx
│   ├── lib/
│   │   ├── actions/                 # Server Actions
│   │   │   ├── productActions.ts    # Product CRUD
│   │   │   ├── orderActions.ts      # Order management
│   │   │   ├── checkoutAction.ts    # Checkout flow
│   │   │   └── settingsActions.ts
│   │   ├── validation/
│   │   │   └── stockValidation.ts   # Stock checks
│   │   ├── db.ts                    # Prisma client
│   │   └── storeSettings.ts         # Settings cache
│   ├── services/
│   │   ├── payment/
│   │   │   ├── PaymentService.ts    # Main orchestrator
│   │   │   ├── core/
│   │   │   │   └── PaymentProvider.ts # Abstract base
│   │   │   ├── providers/
│   │   │   │   └── PayPalProvider.ts
│   │   │   └── factory/
│   │   │       └── PaymentProviderFactory.ts
│   │   └── s3.ts                    # AWS S3 operations
│   ├── hooks/
│   │   ├── use-checkout-state.ts    # Checkout state machine
│   │   ├── use-payment-recovery.ts  # Background polling
│   │   └── use-hydration.ts         # SSR/client sync
│   ├── store/
│   │   ├── cartStore.ts             # Zustand cart state
│   │   └── modalStore.ts            # UI modal state
│   ├── schemas/
│   │   ├── productSchema.ts         # Product validation
│   │   ├── checkoutSchema.ts        # Checkout validation
│   │   └── settingsSchema.ts
│   ├── utils/
│   │   └── currencyUtils.ts         # Minor units handling
│   └── constants/
│       └── storeSettings.ts         # Settings definitions
└── prisma/
    └── schema.prisma                # Database schema`}
</FileTree>

## Core Features

<FeatureList>
  <Feature title="Product Management (Admin)">
    Complete CRUD for products with all the bells and whistles. **Product
    Fields:** - Name, description, SKU - Price with "compare at" price for sales
    - Stock tracking (null = unlimited, 0 = out of stock, number = available) -
    Digital vs Physical product types - Category system - Status: DRAFT, ACTIVE,
    ARCHIVED **Multi-Image Upload:** - Direct client-to-S3 uploads via presigned
    URLs - Drag-and-drop reordering with sortOrder field - Automatic S3 cleanup
    on delete or replace - Secure filename generation prevents path traversal
    **Slug Generation:** - Automatic unique slug from product name -
    URL-friendly format - Uniqueness validation **Smart Cleanup:** If product
    creation fails after images upload, the system automatically deletes
    orphaned S3 objects. No manual cleanup needed.
  </Feature>
  <Feature title="Shopping Cart">
    Client-side cart with localStorage persistence and stock validation.
    **Features:** - Add/update/remove items - Quantity management with stock
    checks - Real-time total calculation - Persists across browser sessions -
    Hydration handling prevents SSR/client mismatches **Stock Validation:** -
    Soft check on add-to-cart (warns if low stock) - Hard check on checkout
    (atomic transaction) - Confirmation modal if adjustments needed **User
    Experience:** - Toast notifications for feedback - Loading states on actions
    - Smooth quantity updates - Clear "out of stock" indicators
  </Feature>
  <Feature title="Advanced Checkout System">
    This is where things get interesting. The checkout handles edge cases most
    stores ignore. **Multi-Step Flow:** 1. **Form Step** - Customer info and
    shipping address 2. **Payment Step** - PayPal integration (more providers
    easy to add) 3. **Processing Step** - Payment capture with recovery 4.
    **Success/Error** - Confirmation or helpful error **Stock Validation with
    Confirmation:** Before payment, the system validates in an atomic
    transaction: - Products still active? - Prices haven't changed? (tampering
    prevention) - Stock available? If issues found, shows
    StockConfirmationModal: - Lists removed or reduced items - Shows adjusted
    total vs original - User confirms to proceed with changes - Or cancels to
    review cart **Atomic Transactions:** All checkout operations happen in a
    single database transaction. Either everything succeeds or nothing changes.
    Prevents race conditions where two users checkout the last item
    simultaneously. **Payment Recovery System:** Handles the webhook race
    condition problem (see challenges section). Polls for 40 seconds before
    showing error. Prevents false negatives.
  </Feature>
  <Feature title="Provider-Agnostic Payment System">
    This is probably the most over-engineered part, but it's worth it for
    flexibility. **Architecture:** ``` PaymentService (orchestration) ↓
    PaymentProviderFactory (dynamic creation) ↓ PaymentProvider (abstract
    interface) ↓ PayPalProvider (concrete implementation) ``` **Why This
    Design?** Adding Stripe or Square is trivial - just implement the
    PaymentProvider interface. No changes to checkout code. The service layer
    handles everything. **Features:** - Create payment orders - Capture approved
    payments - Process refunds (full or partial) - Webhook processing with
    signature verification - Retry logic with exponential backoff -
    Currency-based auto-provider selection - Comprehensive error handling
    **Provider Operations:** - `createPayment()` - Initialize order with return
    URLs - `capturePayment()` - Finalize after user approval - `refundPayment()`
    - Issue refunds - `verifyWebhook()` - Validate webhook signatures -
    `handleWebhook()` - Process webhook events Currently supports PayPal. Stripe
    implementation is ~200 lines of code (interface is already defined).
  </Feature>
  <Feature title="Order Management (Admin)">
    Full admin dashboard for managing orders. **Order Listing:** - Paginated
    table with search/filter - Search by order number, customer name, email -
    Filter by status, payment status - Sort by date, total amount **Order
    Details:** - Customer information card - Order items with images and prices
    - Payment details (transaction ID, amounts) - Order timeline (status
    history) **Status Management:** Orders follow a workflow: - **Digital
    products:** PENDING → CONFIRMED → COMPLETED - **Physical products:** PENDING
    → CONFIRMED → PROCESSING → SHIPPED → DELIVERED → COMPLETED Only valid
    transitions are shown (can't skip from PENDING to SHIPPED). **Refund
    Processing:** - Initiate refunds directly from order page - Full or partial
    refund amounts - Calls payment provider to process - Updates order with
    refund details - Sets payment status to REFUNDED
  </Feature>
  <Feature title="Store Settings System">
    Centralized configuration stored in database, cached for performance.
    **Setting Categories:** - **Store Identity:** Name, description, contact -
    **Operational:** Currency, tax rate - **Content:** Policies, terms -
    **Business:** Shipping costs, free shipping threshold - **Email Templates:**
    Order confirmations, shipping updates - **Appearance:** Theme colors, logo
    **Technical Implementation:** - Type-safe settings with Zod validation -
    1-hour cache with tag-based revalidation - Default fallbacks if database
    empty - Admin UI for editing all settings - Automatic validation on save
    **Why Database-Backed?** Configuration changes don't require redeployment.
    Update shipping costs or tax rates instantly without touching code.
  </Feature>
  <Feature title="Image Management">
    Direct S3 uploads with presigned URLs - no images through your server.
    **Upload Flow:** 1. Client requests presigned URL from `/api/upload-url` 2.
    Server generates secure S3 URL (60-second expiry) 3. Client uploads directly
    to S3 4. Form submits with S3 key (not image data) 5. Product saves with
    image references **Benefits:** - Reduces server bandwidth - Faster uploads
    (direct to CDN) - Scales infinitely (S3 handles it) - Secure (presigned URLs
    expire quickly) **Cleanup:** - Product deletion → delete all associated
    images from S3 - Product update → delete removed images from S3 - Failed
    creation → cleanup uploaded images automatically
  </Feature>
</FeatureList>

## The Payment Webhook Problem

<Collapse title="Race Condition Solution">

**The Problem:**

When users complete PayPal checkout, two things happen:

1. Client-side capture request
2. PayPal webhook notification

These are **asynchronous** and can arrive in **any order**. Sometimes the webhook arrives first, sometimes the capture completes first. Sometimes the capture fails client-side but the webhook succeeds.

**Scenarios:**

**Scenario A: Capture First (Happy Path)**

```
User approves → Capture succeeds → Order updated → Webhook arrives → Duplicate check → Skip
```

✅ Works perfectly

**Scenario B: Webhook First**

```
User approves → Webhook arrives → Order updated → Capture succeeds → Duplicate check → Skip
```

✅ Also works

**Scenario C: Network Error (The Problem)**

```
User approves → Network timeout → Capture fails → Webhook succeeds (actually paid!)
```

❌ Without recovery, user sees error despite successful payment

**The Solution: Payment Recovery System**

Instead of immediately showing an error when capture fails, we poll the order status:

```typescript
// usePaymentRecovery hook
useEffect(() => {
  if (checkoutState.state !== "recovery") return;

  const pollInterval = setInterval(async () => {
    const order = await checkOrderStatus(orderId);

    if (order.paymentStatus === "COMPLETED") {
      // Webhook completed it! Show success
      checkoutActions.setSuccess(orderId);
      clearInterval(pollInterval);
    }

    if (attemptsExhausted) {
      // 40 seconds passed, genuine failure
      checkoutActions.setError("Payment failed");
      clearInterval(pollInterval);
    }
  }, 2000); // Poll every 2 seconds
}, [checkoutState.state]);
```

**Recovery Window:**

- Polls every 2 seconds
- 20 total attempts = 40 seconds
- If webhook completes payment → success
- If 40 seconds pass with no update → genuine error

**Why 40 seconds?**
PayPal typically sends webhooks within 10-20 seconds. 40 seconds gives plenty of buffer while not making users wait forever.

**User Experience:**
Instead of seeing "Payment failed" when it actually succeeded, users see:

1. "Processing payment..." (recovery state)
2. Spinner with helpful text
3. After webhook arrives → "Success! Order confirmed"
4. Or after 40s → "Payment failed" (genuine error)

**Implementation:**

- `use-payment-recovery.ts` - Background polling hook
- `use-checkout-state.ts` - State machine with 'recovery' state
- `checkoutAction.ts` - Idempotent webhook handler

This makes the checkout resilient to network issues and timing problems.

</Collapse>

## Database Schema

<Collapse title="Prisma Models">

**Product & Images:**

```prisma
model Product {
  id              String          @id @default(uuid())
  name            String
  slug            String          @unique
  description     String?
  price           Int             // Stored in cents
  compareAtPrice  Int?            // Original price for sales
  sku             String?         @unique
  stock           Int?            // null = unlimited
  category        String?
  status          ProductStatus   @default(DRAFT)
  productType     ProductType     @default(PHYSICAL)
  images          ProductImage[]
  orderItems      OrderItem[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

model ProductImage {
  id        String  @id @default(uuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  imageUrl  String
  imageKey  String  // S3 key for deletion
  sortOrder Int     @default(0)
}
```

**Orders & Order Items:**

```prisma
model Order {
  id                String        @id @default(uuid())
  orderNumber       String        @unique
  customerName      String
  customerEmail     String
  shippingAddress   Json          // Flexible address structure
  items             OrderItem[]
  status            OrderStatus   @default(PENDING)
  paymentStatus     PaymentStatus @default(CREATED)
  paymentMethod     String
  providerId        String
  providerPaymentId String?
  transactionId     String?
  subtotal          Int           // Cents
  taxAmount         Int
  shippingCost      Int
  totalAmount       Int
  paidAmount        Int?
  paidAt            DateTime?
  refundedAmount    Int?
  refundedAt        DateTime?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
}

model OrderItem {
  id        String  @id @default(uuid())
  orderId   String
  order     Order   @relation(fields: [orderId], references: [id])
  productId String
  product   Product @relation(fields: [productId], references: [id])
  quantity  Int
  price     Int     // Price at time of purchase
  @@index([orderId])
}
```

**Key Design Choices:**

1. **Prices in Cents:** Eliminates floating-point errors. $19.99 = 1999.
2. **Order Items Snapshot Price:** Records price at purchase time, not current price.
3. **Cascade Delete:** Deleting product removes images automatically.
4. **Json for Address:** Flexible structure for different countries.
5. **Status Enums:** Type-safe workflow transitions.

</Collapse>

## Technical Challenges & Solutions

<Challenge
  title="Challenge 1: PayPal's Webhook Timing Is a Nightmare"
  problem="PayPal sends webhooks whenever it feels like it. Sometimes the webhook arrives first, sometimes your capture request completes first. Worst case: the capture fails on the client side due to a network hiccup, but PayPal actually processed the payment. So the user paid, but your app shows 'Payment failed.' Not great."
  solution="Instead of immediately showing an error when capture fails, I poll the order status for 40 seconds. If a webhook came through and completed the payment, we show success. Only after 40 seconds of nothing do we actually show an error. Added a 'recovery' state to the checkout state machine just for this."
  result="No more false 'payment failed' messages. The 40-second window catches all the delayed webhooks. Users get accurate feedback about what actually happened."
/>

<Challenge
  title="Challenge 2: Two People Buying the Last Item"
  problem="Your cart is client-side, stock changes are server-side. What happens when two people add the last item to their cart and checkout at the same time? Or worse - someone keeps an item in their cart for 3 days, prices change, and they try to checkout. You can't trust client-side state."
  solution="Built three-phase validation: soft check on add-to-cart (warns but doesn't block), hard check in an atomic transaction right before order creation, and a confirmation modal if anything changed. Everything happens in one transaction - either it all works or nothing happens. No race conditions."
  result="Impossible to oversell. Users get clear feedback if stock changed. The code for actually deducting stock is there, just commented out on line 74 in checkoutAction.ts - ready when you need it."
/>

<Challenge
  title="Challenge 3: Orphaned S3 Images Costing Me Money"
  problem="Product creation is two steps: upload images to S3, then save to database. If the database save fails (validation error, network issue, whatever), those images are stuck in S3 forever. I've wasted money on this before."
  solution="Track all uploaded image keys in the form state. If the database save fails, immediately delete those S3 objects. Presigned URLs expire in 60 seconds so people can't abuse the upload endpoint. When updating products, compare old and new images and only delete what changed. Prisma cascade deletes handle the rest."
  result="No orphaned images. Storage stays clean automatically. Lower S3 bills. Safe to retry failed uploads."
/>

<Challenge
  title="Challenge 4: React Hydration Errors Everywhere"
  problem="Cart lives in localStorage (client-only), but Next.js renders everything on the server first. The server has no idea what's in your cart, so it renders empty. Then the client loads and suddenly the cart has items. React freaks out: 'Expected server HTML to match client HTML'."
  solution="Made a useHydration hook that waits for the client to mount before rendering the cart. Server always shows a loading state, client takes over after hydration. Zustand's persist middleware only saves the items array, not computed values. Clean separation between server and client state."
  result="No hydration errors. Cart loads smoothly. Everything persists across refreshes and sessions."
/>

<Challenge
  title="Challenge 5: Not Wanting to Be Locked Into PayPal"
  problem="If I hard-code PayPal everywhere, adding Stripe later means rewriting the entire checkout. Each provider has a different API, different error handling, different everything. But the checkout flow shouldn't care which payment provider you're using."
  solution="Built an abstraction layer with the factory pattern. PaymentProvider is an abstract class that defines the interface. PayPalProvider implements it. Want to add Stripe? Just implement the same interface. The checkout code doesn't change at all. PaymentService handles the orchestration."
  result="Adding Stripe would take about 200 lines of code. Zero coupling between checkout and payment implementation. Easy to test with mock providers. Could support multiple currencies with different providers."
/>

<Challenge
  title="Challenge 6: Managing Checkout State Without Losing My Mind"
  problem="Checkout has like 6 different states: form → payment → processing → recovery → success/error. State transitions need to be predictable. You can't just jump from 'payment' back to 'form' randomly. Debugging async state bugs is hell."
  solution="Built a reducer-based state machine in useCheckoutState. All states and transitions are explicit. Actions control everything. Added computed boolean flags like isForm, isPayment, isProcessing to keep component logic simple. The recovery state is separate from error so webhook polling doesn't break things."
  result="State transitions are predictable and debuggable. Redux DevTools works if you need it. Impossible to get into weird invalid states. Component code is actually readable."
/>

<Challenge
  title="Challenge 7: JavaScript Thinks 0.1 + 0.2 ≠ 0.3"
  problem="JavaScript's floating-point math is garbage for money. 0.1 + 0.2 = 0.30000000000000004. Try calculating tax on $19.99 and watch the rounding errors pile up. You absolutely cannot use floats for financial calculations."
  solution="Store everything in cents as integers. $19.99 = 1999. All math is integer-based. Utility functions convert between dollars and cents for display. PayPal's API accepts cents natively anyway, so no conversion errors."
  result="Zero rounding errors ever. Tax and shipping calculations are always exact. No surprises when numbers don't add up."
/>

<Challenge
  title="Challenge 8: Querying Settings on Every Request Is Dumb"
  problem="Store settings get read on almost every page load, but they barely ever change. Hitting the database every time is wasteful. But when you do update settings in the admin panel, you want them to update immediately, not in 24 hours."
  solution="Used unstable_cache with a 1-hour TTL and revalidation tags. First request hits the database, then it's cached in memory. When settings change in the admin panel, call revalidateTag('store-settings') to instantly bust the cache. Zod validates everything, defaults kick in if database is empty."
  result="Settings load in under 1ms. Updates are instant when you change them. Database load dropped significantly. Type safety prevents bad configs from sneaking in."
/>

## Performance Optimizations

<FeatureGrid>
  <FeatureCard title="S3 Direct Uploads">
    Images upload directly from client to S3, bypassing server. Reduces server
    bandwidth and load. Scales infinitely without server upgrades.
  </FeatureCard>
  <FeatureCard title="Settings Cache">
    1-hour cache with tag-based revalidation. Settings read from memory after
    first fetch. Reduces database queries from thousands to dozens per hour.
  </FeatureCard>
  <FeatureCard title="Minor Units for Money">
    Integer math is faster than floating-point. No rounding errors. Calculations
    are predictable and precise.
  </FeatureCard>
  <FeatureCard title="Atomic Transactions">
    Single database transaction for checkout prevents multiple round trips.
    All-or-nothing approach is faster than multi-step commits.
  </FeatureCard>
  <FeatureCard title="Zustand Persistence">
    Cart state persists to localStorage only. No server-side cart storage
    needed. Reduces database writes and API calls.
  </FeatureCard>
  <FeatureCard title="Server Components">
    Product listings render on server with fresh data. No client-side loading
    spinners. Faster initial page load. Better SEO.
  </FeatureCard>
</FeatureGrid>

## Why This Template Approach?

Most developers rebuild e-commerce from scratch every time. That's wasteful. The hard problems are always the same:

- Payment webhooks
- Stock management
- Image uploads
- Checkout flow
- Admin dashboard

**The Template Way:**

1. Clone this repo
2. Customize branding (colors, logo, name)
3. Configure payment provider
4. Add your products
5. Deploy

Everything else is already done. The edge cases are handled. The architecture is solid.

**What You Get:**

- Production-ready code
- All edge cases handled
- Extensible architecture
- Admin dashboard included
- Payment system ready
- Dark mode support
- Mobile responsive
- Type-safe throughout

**Time Saved:**
Building this from scratch: **3-4 weeks**
Customizing this template: **2-3 days**

That's the point.

Clone it, customize it, deploy it. That's the template philosophy.
