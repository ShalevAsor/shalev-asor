---
title: "Second Brain"
slug: "second-brain"
description: "AI-powered note-taking app for STEM/CS students with semantic search and smart organization"
date: "2025-10-01"
published: true
featured: true
tags:
  [
    "nextjs",
    "typescript",
    "react",
    "ai",
    "prisma",
    "postgresql",
    "shadcn/ui",
    "react query",
    "TipTap",
    "clerk",
  ]
github: "https://github.com/ShalevAsor/second-brain"
demo: "https://second-brain-inky-two.vercel.app"
image: ../../../public/images/projects/second-brain/main.png
---

## Overview

I built this because I was tired of losing my notes across random text files and forgotten Google Docs. Second Brain is basically my solution to the note-taking mess that every CS student deals with - pasting code snippets, saving algorithm explanations, keeping track of stuff you learned.

The main idea: paste anything, and AI figures out where it should go and what tags make sense. No more "misc notes" folder with 500 files.

<Callout type="success" title="What It Does">
  - Paste random content → AI organizes it automatically
  - Search by meaning, not just keywords
  - Rich text editor with code blocks, LaTeX math, syntax highlighting
</Callout>

Built it mainly for CS students, bootcamp people, and anyone learning to code who's drowning in notes.

<Stats>
  <StatCard value="5s" label="Save" trend="neutral" />
  <StatCard value="300ms" label="Search" trend="neutral" />
  <StatCard value="2000+" label="Notes Supported" trend="neutral" />
  <StatCard value="30+" label="Code Languages" trend="neutral" />
</Stats>

## Interface Preview

<Figure
  src="/images/projects/second-brain/dashboard.png"
  alt="Second Brain main dashboard interface"
  caption="Clean interface with sidebar navigation, all modals clickable with keyboard shortcuts"
  width="full"
/>

## Tech Stack

<Tabs defaultTab={0}>
  <TabItem label="Frontend">
    
<TechStack 
  title="Core Framework"
  items={[
    "Next.js 15 with App Router for server and client components",
    "TypeScript in strict mode for type safety",
    "Tailwind CSS for styling",
    "SCSS for TipTap styling (following TipTap patterns)",
    "shadcn/ui for ui components"
  ]}
/>

<TechStack
  title="Rich Text Editor"
  items={[
    "Tiptap Editor for rich text editing with custom components and features",
    "lowlight for syntax highlighting (30+ languages)",
    "LaTeX math support for equations",
    "Code blocks",
    "Custom AI Powered Formatter using OpenAI SDK",
  ]}
/>

<TechStack
  title="State Management"
  items={[
    "React Query for server state",
    "Zustand for global client UI state",
    "useReducer for complex local state",
    "useState for simple local state",
  ]}
/>

  </TabItem>
  
  <TabItem label="Backend">
    
<TechStack 
  title="API & Database"
  items={[
    "Next.js Server Actions for type-safe API",
    "PostgreSQL for relational data storage",
    "Prisma ORM for database access",
    "Zod for server side validation"
  ]}
/>

<TechStack
  title="Authentication"
  items={[
    "Clerk for authentication",
    "Webhook support for user sync and fallback",
  ]}
/>

  </TabItem>
  
  <TabItem label="AI Services">
    
<TechStack 
  title="OpenAI Integration"
  items={[
    "GPT-4o-mini for content analysis and formatting",
    "text-embedding-3-small for semantic search (1536 dimensions)",
    "Custom prompt engineering for organization",
    "Token optimization and cost control"
  ]}
/>

<TechStack
  title="AI Features"
  items={[
    "Lazy embedding generation (on-demand)",
    "Semantic search with cosine similarity",
    "Automatic content organization",
    "Smart folder and tag suggestions",
    "Automatic formatter fully support Text Editor features",
  ]}
/>

  </TabItem>
  
  <TabItem label="DevOps">
    
<TechStack 
  items={[
    "Vercel for deployment and hosting",
    "PostgreSQL hosted on Neon DB",
    "npm for package management",
    "Git for version control"
  ]}
/>

  </TabItem>
</Tabs>

## Project Structure

<FileTree>
  {`src/
├── actions/              # Server actions (API layer)
│   ├── aiActions.ts      # AI features
│   ├── noteActions.ts    # Note CRUD
│   ├── folderActions.ts  # Folder management
│   └── tagActions.ts     # Tag operations
├── app/                  # Next.js App Router
│   ├── (auth)/          # Auth pages
│   ├── (main)/          # Main app
│   │   ├── layout.tsx   # Sidebar + header
│   │   └── notes/       # Notes routes
│   │       ├── page.tsx
│   │       ├── new/
│   │       └── [id]/
│   └── api/webhooks/    # Clerk webhooks
├── components/
│   ├── editor/          # Note editor
│   ├── modals/          # Dialogs
│   │   ├── QuickCaptureModal.tsx
│   │   └── SearchModal.tsx
│   ├── sidebar/         # Navigation
│   └── ui/              # shadcn components
├── hooks/               # React Query hooks
│   ├── use-notes.ts
│   ├── use-folders.ts
│   └── use-semantic-search.ts
├── lib/                 # Utilities
│   ├── prisma.ts
│   ├── queryClient.ts
│   └── auth.ts
├── services/            # External services
│   └── ai/
│       ├── content-analyzer.ts
│       ├── semantic-search.ts
│       └── prompts/
└── schemas/             # Zod validation
    ├── noteSchemas.ts
    └── folderSchemas.ts`}
</FileTree>

## Database Architecture

<Collapse title="Database Schema">

Using PostgreSQL with Prisma. Pretty straightforward setup:

**Main tables:**

- **User** - Synced from Clerk
- **Note** - The actual content plus AI embeddings
- **Folder** - Up to 3 levels deep (enough for most people)
- **Tag** - Many-to-many with notes

**The embedding fields:**

```prisma
model Note {
  // ... other fields

  embedding          Float[]    // 1536-dimension vector from OpenAI
  embeddingUpdatedAt DateTime?  // When we last generated this
  contentUpdatedAt   DateTime   // When content last changed
}
```

<Callout type="info" title="Lazy Embeddings">
  Only generate embeddings **when you actually search** and **only for notes that changed**. This cuts API costs by 90% and doesn't slow down note creation at all.
</Callout>

**Folder rules:**

- Max 3 levels (prevents folder inception)
- Cascade deletes so you don't get orphaned stuff
- Every user gets an "Inbox" folder by default

**Tags:**

- Stored lowercase to avoid duplicates
- Hyphenated format (like "hash-table" not "hashtable")

</Collapse>

<Collapse title="Architecture Patterns">

### Server Actions Pattern

All server operations follow a consistent pattern:

```typescript
export async function actionName(
  input: InputType
): Promise<ActionResult<ReturnType>> {
  try {
    // 1. Authenticate
    const userId = await requireAuth();

    // 2. Validate input
    const validated = zodSchema.parse(input);

    // 3. Database operation
    const result = await prisma.model.operation({
      where: { userId },
      data: validated,
    });

    // 4. Revalidate cache
    revalidatePath("/notes");

    // 5. Return typed success
    return createSuccessResult(result);
  } catch (error) {
    return createErrorResult({ error: "Failed" });
  }
}
```

<Callout type="info" title="Why ActionResult?">
  Using a discriminated union type (`success: true | false`) instead of throwing
  errors makes error handling in components more predictable and type-safe.
</Callout>

<Collapse title="React Query Optimistic Updates">

One of the key patterns making the app feel instant is optimistic updates. When a user performs an action, we immediately update the UI before waiting for the server response.

**Example: Creating a Note**

```typescript
export function useCreateNote() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createNote,

    // 1. Optimistic update (before server responds)
    onMutate: async (newNote) => {
      // Cancel outgoing queries to avoid race conditions
      await queryClient.cancelQueries({ queryKey: NOTES_QUERY_KEY });

      // Snapshot current state for rollback
      const previous = queryClient.getQueryData(NOTES_QUERY_KEY);

      // Immediately add note to cache
      queryClient.setQueryData(NOTES_QUERY_KEY, (old) => {
        return [...(old || []), optimisticNote];
      });

      return { previous };
    },

    // 2. Rollback on error
    onError: (err, variables, context) => {
      queryClient.setQueryData(NOTES_QUERY_KEY, context?.previous);
      toast.error("Failed to create note");
    },

    // 3. Sync with server on completion
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: NOTES_QUERY_KEY });
      queryClient.invalidateQueries({ queryKey: FOLDERS_QUERY_KEY });
      queryClient.invalidateQueries({ queryKey: TAGS_QUERY_KEY });
    },

    // 4. Success feedback
    onSuccess: (data) => {
      toast.success("Note created!");
    },
  });
}
```

<Callout type="success" title="Why This Matters">
  Users see their changes instantly without waiting for the server. If the
  server fails, we rollback automatically. This creates a snappy, responsive
  experience that feels native.
</Callout>

**Result:** The UI updates in < 50ms instead of waiting 200-500ms for the server. If something fails, the user sees the error and the UI reverts gracefully.

</Collapse>

</Collapse>

## Core Features

<FeatureList>

<Feature title="Rich Text Editor">
  Full-featured Tiptap editor with: - **Text Formatting:** Bold, italic,
  underline, strikethrough, code, highlight - **Headings:** H1-H6 with visual
  hierarchy - **Lists:** Bullet, numbered, task lists with checkboxes - **Code
  Blocks:** Syntax highlighting for 30+ languages via lowlight - **Math
  Support:** Inline and block LaTeX equations - **Auto-Save:** Debounced saving
  every 2 seconds with visual indicators
  <ImageGallery
    columns={2}
    images={[
      {
        src: "/images/projects/second-brain/editor-code-block.png",
        alt: "Code block with syntax highlighting",
        caption: "Syntax highlighting for 30+ languages",
      },
      {
        src: "/images/projects/second-brain/editor-math-block.png",
        alt: "LaTeX math equations",
        caption: "Inline and block LaTeX support",
      },
    ]}
  />
</Feature>

<Feature title="Smart Folder System">
  Organize notes in a 3-level hierarchy with: - **Custom Colors:** 6 options
  (Gray, Red, Green, Blue, Yellow, Purple) - **Special Inbox:** Auto-created for
  unorganized content - **Validation:** Prevents circular references and
  duplicate names - **Note Organization:** Move notes between folders

  <Figure 
  src="/images/projects/second-brain/folders-modal.png"
  alt="Folder hierarchy with color coding"
  caption="3-level folder structure with custom colors"
  width="sm"
/>
</Feature>

<Feature title="Quick Capture (AI-Powered)">
  Paste anything and AI organizes it automatically: - **Smart Analysis:**
  Suggests title, folder, and tags (3-5 seconds) - **Folder Matching:** Prefers
  existing folders, creates new if needed - **Tag Intelligence:** Reuses
  existing tags + adds specific new ones - **Content Formatting:** Converts
  plain text to rich HTML
</Feature>

<Feature title="AI-Powered Content Formatter">
  Transform plain text into beautifully formatted rich text: - **Smart Structure
  Detection:** Automatically detects headings, lists, and code blocks - **Code
  Syntax Highlighting:** Preserves code formatting with proper language
  detection - **Math Support:** Converts LaTeX notation to rendered equations -
  **Full Editor Support:** Works seamlessly with all Tiptap features - **Fast
  Processing:** Formats content in 2-3 seconds using OpenAI GPT-4o-mini
</Feature>

<Feature title="Semantic Search">
  AI-powered search that understands meaning: - **Natural Language:** Search
  like "how to sort arrays efficiently" - **Context-Aware:** Finds related notes
  even without exact keywords - **Fast Results:** 300-500ms after first search
  (embeddings cached) - **Similarity Scores:** See how relevant each result is
  (0-100%)
</Feature>

</FeatureList>

## How Quick Capture Works

Quick Capture uses AI to analyze pasted content and automatically organize it.

<ImageGallery
  columns={2}
  images={[
    {
      src: "/images/projects/second-brain/quick-capture-1.png",
      alt: "Quick Capture modal",
      caption: "Quick Capture modal",
    },
    {
      src: "/images/projects/second-brain/quick-capture-2.png",
      alt: "Ai Analysis results",
      caption: "Ai Analysis results",
    },
  ]}
/>

<Collapse title="AI Folder Logic">

The AI follows specific rules for folder suggestions:

**1. Prefer Existing Folders**

- Searches for semantic matches in user's folder structure
- Prefers most specific match (e.g., "Algorithms/Sorting" over "Algorithms")
- Case-insensitive, path-aware matching

**2. Create New Only at Root**

- If no match found, suggests NEW root-level folder
- Never suggests nested paths for new folders
- Example: "Recipes" (✅) not "Cooking/Desserts" (❌)

**3. Use Inbox for Vague Content**

- Generic or unclear content → suggest "Inbox"
- Prevents creation of useless folders like "misc" or "temp"

**Example:**

```
User pastes: Python merge sort code
Existing folders: Algorithms/Sorting, Recipes
AI suggests: "Algorithms/Sorting" ✅
```

</Collapse>

<Collapse title="AI Tag Logic">

**Tag Suggestion Rules:**

1. **Always reuse existing tags when relevant**

   - Prevents tag proliferation
   - Maintains consistency

2. **Add new specific tags for discoverability**

   - Balance: Broad existing + Specific new
   - Example: Hash table code + existing "algorithms" tag
   - Result: `["algorithms", "hash-table", "data-structures"]`

3. **Clear content: 2-5 tags, Vague content: 0-1 tags**

4. **Lowercase, hyphenated format**
   - "python" not "Python"
   - "hash-table" not "hash_table" or "hashtable"

</Collapse>

## Semantic Search

<ImageGallery
  columns={2}
  images={[
    {
      src: "/images/projects/second-brain/semantic-search-1.png",
      alt: "Semantic search first time",
      caption: "First search - generates embeddings (takes 2-3s)",
    },
    {
      src: "/images/projects/second-brain/semantic-search-2.png",
      alt: "Semantic search cached",
      caption: "Second search - uses cached embeddings (300ms)",
    },
  ]}
/>

The search uses "lazy embeddings" - basically I don't generate them until you actually search for something.

<Callout type="success" title="Why This Approach?">
  - Creating notes is instant (no embedding generation)
  - First search takes 2-3 seconds (has to generate for all notes)
  - Every search after that is 300ms
  - Saves a ton of money on API calls
  - Only regenerates for notes you've edited
</Callout>

### Embedding Freshness Logic

The system intelligently decides when to regenerate embeddings:

<Tabs>
<TabItem label="Needs Regeneration">

<TechStack
  items={[
    "No embedding exists - First time searching this note",
    "Missing timestamp - Corrupted metadata",
    "Content updated - contentUpdatedAt > embeddingUpdatedAt",
  ]}
/>

</TabItem>

<TabItem label="Fresh (Use Cache)">

<TechStack
  items={[
    "Has embedding - Not null or empty",
    "Has timestamp - embeddingUpdatedAt exists",
    "Content unchanged - contentUpdatedAt <= embeddingUpdatedAt",
  ]}
/>

</TabItem>
</Tabs>

## Challenges & Solutions

<Challenge
  title="Challenge 1: Managing Form State"
  problem="The note editor has like 5 different fields that all affect each other - title, content, folder, tags, favorite status. I started with a bunch of useState hooks and it turned into a mess of sync issues."
  solution="Switched to useReducer. Now I have one source of truth for the form state and typed actions like SET_TITLE, ADD_TAG, TOGGLE_FAVORITE. Way cleaner and actually testable."
  result="Adding new fields is easy now, and I stopped getting weird state bugs where the UI didn't match the data."
/>

<Challenge
  title="Challenge 2: Search Was Too Slow"
  problem="I was generating embeddings every time someone created a note. This meant 2-3 second waits after every save. Terrible UX and was costing me money in API calls."
  solution="Switched to lazy embeddings - only generate when someone actually searches. Cache them in the database and only regenerate if the content changed. First search is slower but every search after is instant."
  result="Note creation is instant now. First search takes a few seconds but then it's 300ms. Cut my OpenAI bill by 90%."
/>

<Challenge
  title="Challenge 3: Matching AI Folder Suggestions"
  problem="The AI would suggest paths like 'Algorithms/Sorting' but my database stores folders flat with just a parentId reference. Had to figure out how to match AI suggestions to actual folder structures."
  solution="Built a recursive function that walks up the parent chain to build full paths for every folder. Then match the AI suggestion case-insensitively and return the deepest (most specific) match."
  result="Quick Capture now pre-fills the right folders. If you have 'Algorithms/Sorting' and paste sorting code, it actually finds it."
/>

<Challenge
  title="Challenge 4: Auto-Save Without Breaking Things"
  problem="Saving on every keystroke = too many API calls. Saving too rarely = risk losing work. And when people type fast, you get race conditions where saves overlap."
  solution="2-second debounced auto-save. Only saves if the note exists already. Cancels pending saves if the user keeps typing. Shows 'Last saved at...' so people know it worked."
  result="Feels smooth, doesn't spam the API, and I haven't lost any data yet."
/>
